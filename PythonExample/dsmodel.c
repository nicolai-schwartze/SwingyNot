#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Modelica.Mechanics.Rotational.Examples.CoupledClutches
 Dymola Version 2019 FD01 (64-bit), 2018-10-10 translated this at Fri May  3 08:11:43 2019

  OutputCPUtime = true;
 */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[5]={3.0, 2.0, 1.0, 0.0, -1.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divmacro((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#define NX_    8
#define NX2_   0
#define NU_    0
#define NY_    2
#define NW_    88
#define NP_    39
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 500322917
#define NHash2_ 195819585
#define NHash3_ 0
#define NI_    0
#define NRelF_ 27
#define NRel_  27
#define NTim_  4
#define NSamp_ 0
#define NCons_ 0
#define NA_    54
#define SizePre_ 12
#define SizeEq_ 4
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 9
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 111
#define NGlobalHelpI_ 12
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Modelica.Mechanics.Rotational.Examples.CoupledClutches";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/admin/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[14]={3 , 6 , 1 , 2 , 3 , 4 , 5 , 7 , 1 , 6 , 1 , 8
   , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[25]={
2 , 4 , 4 , 4 , 0 , 4 , 0 , 4 , 0 , 6 , 0 , 6 , 6 , 6 , 0 , 6 , 0 , 8 , 0 , 8 , 0
   , 8 , 8 , 8 , 0};
DYMOLA_STATIC double QJacobianCD_[9]={0  , 44 , 55 , 66 , 77 , 88 , 90 , 110 , 99};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
DYNX(Y_,0) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,1) += 1;

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,2) = 3;
DYNX(W_,3) = true;
DYNX(W_,4) = 0.0001;
DYNX(W_,5) = 4;
memcpy(&DYNX(W_,13), &DymArrays0, sizeof(double)*5);
DYNX(W_,19) = 1;
DYNX(W_,20) = 1;
DYNX(W_,21) = false;
DYNX(W_,29) = 3;
DYNX(W_,33) = 0.0001;
DYNX(W_,34) = 4;
memcpy(&DYNX(W_,42), &DymArrays0, sizeof(double)*5);
DYNX(W_,48) = 1;
DYNX(W_,49) = 1;
DYNX(W_,50) = false;
DYNX(W_,55) = 3;
DYNX(W_,59) = 0.0001;
DYNX(W_,60) = 4;
memcpy(&DYNX(W_,68), &DymArrays0, sizeof(double)*5);
DYNX(W_,74) = 1;
DYNX(W_,75) = 1;
DYNX(W_,76) = false;
DYNX(W_,82) = 3;
DYNX(W_,81) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,27) = DYNX(DP_,1);
DYNX(W_,86) = DYNX(DP_,0);
DYNX(W_,87) = DYNX(DP_,2);
BoundParameterConstantSection
DYNX(W_,78) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
  RealTemporaryDense( &DYNX(DP_,26), 1, 1), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,52) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
  RealTemporaryDense( &DYNX(DP_,19), 1, 1), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,23) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
  RealTemporaryDense( &DYNX(DP_,5), 1, 1), 0, 1).yi0_0_0member);
PopAllMarks();
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,10) = false;
DYNX(W_,11) = false;
DYNX(W_,12) = false;
DYNX(W_,18) = 3;
DYNX(W_,30) = 0;
DYNX(W_,31) = 0;
DYNX(W_,39) = false;
DYNX(W_,40) = false;
DYNX(W_,41) = false;
DYNX(W_,47) = 3;
DYNX(W_,56) = 0;
DYNX(W_,57) = 0;
DYNX(W_,65) = false;
DYNX(W_,66) = false;
DYNX(W_,67) = false;
DYNX(W_,73) = 3;
DYNX(W_,83) = 0;
DYNX(W_,84) = 0;
DYNX(F_,3) = 0;
DYNX(F_,5) = 0;
DYNX(F_,7) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,18);
DYNX(Aux_,1) = DYNX(W_,11);
DYNX(Aux_,2) = DYNX(W_,10);
DYNX(Aux_,3) = DYNX(W_,47);
DYNX(Aux_,4) = DYNX(W_,40);
DYNX(Aux_,5) = DYNX(W_,39);
DYNX(Aux_,6) = DYNX(W_,73);
DYNX(Aux_,7) = DYNX(W_,66);
DYNX(Aux_,8) = DYNX(W_,65);
InitialSection
InitialSection2
DYNX(X_,3) = DYNX(W_,31)-DYNX(X_,1);
DYNX(X_,5) = DYNX(W_,57)-DYNX(W_,31);
DYNX(X_,7) = DYNX(W_,84)-DYNX(W_,57);
DYNX(X_,6) = DYNX(W_,83)-DYNX(W_,56);
DYNX(X_,4) = DYNX(W_,56)-DYNX(W_,30);
DYNX(X_,2) = DYNX(W_,30)-DYNX(X_,0);
InitialSection
InitialSection2
DYNX(W_,18) = DYNX(Aux_,0);
DYNX(W_,11) = DYNX(Aux_,1);
DYNX(W_,10) = DYNX(Aux_,2);
DYNX(W_,47) = DYNX(Aux_,3);
DYNX(W_,40) = DYNX(Aux_,4);
DYNX(W_,39) = DYNX(Aux_,5);
DYNX(W_,73) = DYNX(Aux_,6);
DYNX(W_,66) = DYNX(Aux_,7);
DYNX(W_,65) = DYNX(Aux_,8);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,80) = DYNX(DP_,37)+(IF LessTime(DYNX(W_,87), 0) THEN 0 ELSE DYNX(DP_,36));
DYNX(W_,79) = DYNX(DP_,29)*DYNX(W_,80);
DYNX(W_,63) = LessEqual(DYNX(W_,79),"clutch3.fn", 0,"0", 0);
DYNX(W_,61) = DYNX(W_,78)*DYNX(DP_,28)*DYNX(W_,79);
DYNX(W_,62) = DYNX(DP_,27)*DYNX(W_,61);
DYNX(W_,26) = DYNX(DP_,16)+(IF LessTime(DYNX(W_,27), 1) THEN 0 ELSE DYNX(DP_,15));
DYNX(W_,53) = DYNX(DP_,22)*DYNX(W_,26);
DYNX(W_,37) = LessEqual(DYNX(W_,53),"clutch2.fn", 0,"0", 1);
DYNX(W_,0) = DYNX(DP_,13)+(IF LessTime(DYNX(DP_,14), 2) THEN 0 ELSE DYNX(DP_,10)
  *sin(6.283185307179586*DYNX(DP_,11)*(DYNTime-DYNX(DP_,14))+DYNX(DP_,12)));
DYNX(W_,25) = DYNX(DP_,34)+(IF LessTime(DYNX(DP_,35), 3) THEN 0 ELSE 
  DYNX(DP_,32)*sin(6.283185307179586*DYNX(W_,86)*(DYNTime-DYNX(DP_,35))+
  DYNX(DP_,33)));
DYNX(W_,24) = DYNX(DP_,8)*DYNX(W_,25);
DYNX(W_,8) = LessEqual(DYNX(W_,24),"clutch1.fn", 0,"0", 2);
DYNX(W_,6) = DYNX(W_,23)*DYNX(DP_,7)*DYNX(W_,24);
DYNX(W_,7) = DYNX(DP_,6)*DYNX(W_,6);
DYNX(W_,35) = DYNX(W_,52)*DYNX(DP_,21)*DYNX(W_,53);
DYNX(W_,36) = DYNX(DP_,20)*DYNX(W_,35);

MixedSystemOfEquations(13, DYNX(DYNhelp,0))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 23 common subexpressions used in 12 expressions */
  /* Of the common subexpressions 23 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,13) = IF DYNX(W_,12) THEN 0.0 ELSE IF DYNX(W_,8) THEN 0 ELSE 
    DYNX(DP_,7)*DYNX(W_,24)*(IF DYNX(W_,10) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1), DYNX(X_,3), 1).yi0_0_0member) ELSE 
    IF DYNX(W_,11) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1), DYNX(X_,3), 1).yi0_0_0member) ELSE 
    IF PRE(DYNX(W_,18), 1) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1), DYNX(X_,3), 1).yi0_0_0member) ELSE 
     -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]},  -clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1),  -DYNX(X_,3), 1).yi0_0_0member));
  PopAllMarks();
  DYNX(DYNhelp,14) = IF DYNX(W_,41) THEN 0 ELSE IF DYNX(W_,37) THEN 0.0 ELSE IF 
    DYNX(W_,39) THEN  -DYNX(W_,36) ELSE IF DYNX(W_,40) THEN DYNX(W_,36) ELSE IF 
    PRE(DYNX(W_,47), 3) == 1 THEN  -DYNX(W_,36) ELSE DYNX(W_,36);
  DYNX(DYNhelp,15) = IF DYNX(W_,12) THEN 0 ELSE IF DYNX(W_,8) THEN 0.0 ELSE IF 
    DYNX(W_,10) THEN  -DYNX(W_,7) ELSE IF DYNX(W_,11) THEN DYNX(W_,7) ELSE IF 
    PRE(DYNX(W_,18), 1) == 1 THEN  -DYNX(W_,7) ELSE DYNX(W_,7);
  DYNX(DYNhelp,16) = IF DYNX(W_,67) THEN 0.0 ELSE IF DYNX(W_,63) THEN 0 ELSE 
    DYNX(DP_,28)*DYNX(W_,79)*(IF DYNX(W_,65) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1), DYNX(X_,7), 1).yi0_0_0member)
     ELSE IF DYNX(W_,66) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1), DYNX(X_,7), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,73), 5) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1), DYNX(X_,7), 1).yi0_0_0member)
     ELSE  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]},  -clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1),  -DYNX(X_,7), 1).yi0_0_0member));
  PopAllMarks();
  DYNX(DYNhelp,17) = IF DYNX(W_,41) THEN 0.0 ELSE IF DYNX(W_,37) THEN 0 ELSE 
    DYNX(DP_,21)*DYNX(W_,53)*(IF DYNX(W_,39) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1), DYNX(X_,5), 1).yi0_0_0member)
     ELSE IF DYNX(W_,40) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1), DYNX(X_,5), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,47), 3) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1), DYNX(X_,5), 1).yi0_0_0member)
     ELSE  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]},  -clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1),  -DYNX(X_,5), 1).yi0_0_0member));
  PopAllMarks();
  /* Automatic tearing of linear system of 13 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"J1.der(w)", "clutch3.sa", "clutch2.sa", 
      "clutch1.sa"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,18), 64, 
      DYNX(did_->helpvari_vec,0), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,82) = IF DYNX(W_,12) THEN 1.0 ELSE 0.0;
      DYNX(DYNhelp,83) = IF DYNX(W_,67) THEN 1.0 ELSE 0.0;
      DYNX(DYNhelp,84) = IF DYNX(W_,41) THEN 0.0 ELSE 1.0;
      DYNX(DYNhelp,85) = IF DYNX(W_,12) THEN 0.0 ELSE 1.0;
      DYNX(DYNhelp,86) = IF DYNX(W_,41) THEN 1.0 ELSE 0.0;
      SetMatrixLeading(J, 1, 1, 4, DYNX(DP_,3));
      SetMatrixLeading(J, 1, 4, 4, (-1.0)*DYNX(DYNhelp,82));
      SetMatrixLeading(J, 2, 1, 4, DYNX(DP_,31));
      SetMatrixLeading(J, 2, 2, 4, DYNX(DP_,31)*(IF DYNX(W_,67) THEN 0.0 ELSE 
        1.0)+DYNX(DYNhelp,83));
      SetMatrixLeading(J, 2, 3, 4, DYNX(DP_,31)*DYNX(DYNhelp,84));
      SetMatrixLeading(J, 2, 4, 4, DYNX(DP_,31)*DYNX(DYNhelp,85));
      SetMatrixLeading(J, 3, 1, 4, DYNX(DP_,24));
      SetMatrixLeading(J, 3, 2, 4, (-1.0)*DYNX(DYNhelp,83));
      SetMatrixLeading(J, 3, 3, 4, DYNX(DP_,24)*DYNX(DYNhelp,84)+
        DYNX(DYNhelp,86));
      SetMatrixLeading(J, 3, 4, 4, DYNX(DP_,24)*DYNX(DYNhelp,85));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DP_,17));
      SetMatrixLeading(J, 4, 3, 4, (-1.0)*DYNX(DYNhelp,86));
      SetMatrixLeading(J, 4, 4, 4, DYNX(DYNhelp,82)+DYNX(DP_,17)*
        DYNX(DYNhelp,85));
    }
    SetVector(b, 1, DYNX(W_,0)+DYNX(DYNhelp,13));
    SetVector(b, 2,  -(DYNX(DP_,31)*(IF DYNX(W_,67) THEN 0 ELSE IF DYNX(W_,63)
       THEN 0.0 ELSE IF DYNX(W_,65) THEN  -DYNX(W_,62) ELSE IF DYNX(W_,66) THEN 
      DYNX(W_,62) ELSE IF PRE(DYNX(W_,73), 5) == 1 THEN  -DYNX(W_,62) ELSE 
      DYNX(W_,62))+DYNX(DP_,31)*DYNX(DYNhelp,14)+DYNX(DP_,31)*DYNX(DYNhelp,15)+
      DYNX(DYNhelp,16)));
    SetVector(b, 3,  -(DYNX(DP_,24)*DYNX(DYNhelp,14)+DYNX(DP_,24)*
      DYNX(DYNhelp,15)-DYNX(DYNhelp,16)+DYNX(DYNhelp,17)));
    SetVector(b, 4, DYNX(DYNhelp,17)-(DYNX(DYNhelp,13)+DYNX(DP_,17)*
      DYNX(DYNhelp,15)));
    SetVector(y, 1, RememberSimple_(DYNX(F_,1), 0));
    SetVector(y, 2, RememberSimple_(DYNX(W_,64), 1));
    SetVector(y, 3, RememberSimple_(DYNX(W_,38), 2));
    SetVector(y, 4, RememberSimple_(DYNX(W_,9), 3));
    SolveLinearSystemOfEquationsMixed(J, b, y, 1);
    DYNX(F_,1) = GetVector(y, 1);
    DYNX(W_,64) = GetVector(y, 2);
    DYNX(W_,38) = GetVector(y, 3);
    DYNX(W_,9) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,1) = IF DYNX(W_,12) THEN DYNX(W_,9) ELSE IF DYNX(W_,8) THEN 0 ELSE 
    DYNX(DP_,7)*DYNX(W_,24)*(IF DYNX(W_,10) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1), DYNX(X_,3), 1).yi0_0_0member) ELSE 
    IF DYNX(W_,11) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1), DYNX(X_,3), 1).yi0_0_0member) ELSE 
    IF PRE(DYNX(W_,18), 1) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]}, clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1), DYNX(X_,3), 1).yi0_0_0member) ELSE 
     -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch1.mue_pos[1, 1]}, {clutch1.mue_pos[1, 2]},  -clutch1.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,4), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,5), 1, 1),  -DYNX(X_,3), 1).yi0_0_0member));
  PopAllMarks();
  DYNX(F_,7) = IF DYNX(W_,67) THEN 0 ELSE IF DYNX(W_,63) THEN DYNX(W_,64) ELSE 
    IF DYNX(W_,65) THEN DYNX(W_,64)-DYNX(W_,62) ELSE IF DYNX(W_,66) THEN 
    DYNX(W_,64)+DYNX(W_,62) ELSE IF PRE(DYNX(W_,73), 5) == 1 THEN DYNX(W_,64)-
    DYNX(W_,62) ELSE DYNX(W_,64)+DYNX(W_,62);
  DYNX(F_,5) = IF DYNX(W_,41) THEN 0 ELSE IF DYNX(W_,37) THEN DYNX(W_,38) ELSE 
    IF DYNX(W_,39) THEN DYNX(W_,38)-DYNX(W_,36) ELSE IF DYNX(W_,40) THEN 
    DYNX(W_,38)+DYNX(W_,36) ELSE IF PRE(DYNX(W_,47), 3) == 1 THEN DYNX(W_,38)-
    DYNX(W_,36) ELSE DYNX(W_,38)+DYNX(W_,36);
  DYNX(F_,3) = IF DYNX(W_,12) THEN 0 ELSE IF DYNX(W_,8) THEN DYNX(W_,9) ELSE IF 
    DYNX(W_,10) THEN DYNX(W_,9)-DYNX(W_,7) ELSE IF DYNX(W_,11) THEN DYNX(W_,9)+
    DYNX(W_,7) ELSE IF PRE(DYNX(W_,18), 1) == 1 THEN DYNX(W_,9)-DYNX(W_,7) ELSE 
    DYNX(W_,9)+DYNX(W_,7);
  DYNX(W_,32) = DYNX(F_,3)+DYNX(F_,1);
  DYNX(W_,58) = DYNX(F_,5)+DYNX(W_,32);
  DYNX(W_,85) = DYNX(F_,7)+DYNX(W_,58);
  DYNX(W_,54) = IF DYNX(W_,67) THEN DYNX(W_,64) ELSE IF DYNX(W_,63) THEN 0 ELSE 
    DYNX(DP_,28)*DYNX(W_,79)*(IF DYNX(W_,65) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1), DYNX(X_,7), 1).yi0_0_0member)
     ELSE IF DYNX(W_,66) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1), DYNX(X_,7), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,73), 5) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]}, clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1), DYNX(X_,7), 1).yi0_0_0member)
     ELSE  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch3.mue_pos[1, 1]}, {clutch3.mue_pos[1, 2]},  -clutch3.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,25), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,26), 1, 1),  -DYNX(X_,7), 1).yi0_0_0member));
  PopAllMarks();
  DYNX(W_,28) = IF DYNX(W_,41) THEN DYNX(W_,38) ELSE IF DYNX(W_,37) THEN 0 ELSE 
    DYNX(DP_,21)*DYNX(W_,53)*(IF DYNX(W_,39) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1), DYNX(X_,5), 1).yi0_0_0member)
     ELSE IF DYNX(W_,40) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1), DYNX(X_,5), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,47), 3) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]}, clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1), DYNX(X_,5), 1).yi0_0_0member)
     ELSE  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({clutch2.mue_pos[1, 1]}, {clutch2.mue_pos[1, 2]},  -clutch2.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,18), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,19), 1, 1),  -DYNX(X_,5), 1).yi0_0_0member));
  PopAllMarks();
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,10),"clutch1.startForward", PRE(DYNX(W_,18), 1)
     == 0 AND (Greater(DYNX(W_,9),"clutch1.sa", DYNX(W_,7),"clutch1.tau0_max", 3)
     OR PRE(DYNX(W_,10), 6) AND Greater(DYNX(W_,9),"clutch1.sa", DYNX(W_,6),
    "clutch1.tau0", 4)) OR PRE(DYNX(W_,18), 1) == -1 AND Greater(DYNX(X_,3),
    "clutch1.w_rel", DYNX(DP_,9),"clutch1.w_small", 5) OR initial() AND Greater(
    DYNX(X_,3),"clutch1.w_rel", 0,"0", 6));
  UpdateVariableNamed(DYNX(W_,11),"clutch1.startBackward", PRE(DYNX(W_,18), 1)
     == 0 AND (Less(DYNX(W_,9),"clutch1.sa",  -DYNX(W_,7)," -clutch1.tau0_max", 7)
     OR PRE(DYNX(W_,11), 7) AND Less(DYNX(W_,9),"clutch1.sa",  -DYNX(W_,6),
    " -clutch1.tau0", 8)) OR PRE(DYNX(W_,18), 1) == 1 AND Less(DYNX(X_,3),
    "clutch1.w_rel",  -DYNX(DP_,9)," -clutch1.w_small", 9) OR initial() AND Less
    (DYNX(X_,3),"clutch1.w_rel", 0,"0", 10));
  UpdateVariableNamed(DYNX(W_,12),"clutch1.locked",  NOT DYNX(W_,8) AND  NOT (
    PRE(DYNX(W_,18), 1) == 1 OR DYNX(W_,10) OR PRE(DYNX(W_,18), 1) == -1 OR 
    DYNX(W_,11)));
  UpdateVariableNamed(DYNX(W_,39),"clutch2.startForward", PRE(DYNX(W_,47), 3)
     == 0 AND (Greater(DYNX(W_,38),"clutch2.sa", DYNX(W_,36),"clutch2.tau0_max",
     11) OR PRE(DYNX(W_,39), 8) AND Greater(DYNX(W_,38),"clutch2.sa", 
    DYNX(W_,35),"clutch2.tau0", 12)) OR PRE(DYNX(W_,47), 3) == -1 AND Greater(
    DYNX(X_,5),"clutch2.w_rel", DYNX(DP_,23),"clutch2.w_small", 13) OR initial()
     AND Greater(DYNX(X_,5),"clutch2.w_rel", 0,"0", 14));
  UpdateVariableNamed(DYNX(W_,40),"clutch2.startBackward", PRE(DYNX(W_,47), 3)
     == 0 AND (Less(DYNX(W_,38),"clutch2.sa",  -DYNX(W_,36)," -clutch2.tau0_max",
     15) OR PRE(DYNX(W_,40), 9) AND Less(DYNX(W_,38),"clutch2.sa",  -DYNX(W_,35),
    " -clutch2.tau0", 16)) OR PRE(DYNX(W_,47), 3) == 1 AND Less(DYNX(X_,5),
    "clutch2.w_rel",  -DYNX(DP_,23)," -clutch2.w_small", 17) OR initial() AND 
    Less(DYNX(X_,5),"clutch2.w_rel", 0,"0", 18));
  UpdateVariableNamed(DYNX(W_,41),"clutch2.locked",  NOT DYNX(W_,37) AND  NOT (
    PRE(DYNX(W_,47), 3) == 1 OR DYNX(W_,39) OR PRE(DYNX(W_,47), 3) == -1 OR 
    DYNX(W_,40)));
  UpdateVariableNamed(DYNX(W_,65),"clutch3.startForward", PRE(DYNX(W_,73), 5)
     == 0 AND (Greater(DYNX(W_,64),"clutch3.sa", DYNX(W_,62),"clutch3.tau0_max",
     19) OR PRE(DYNX(W_,65), 10) AND Greater(DYNX(W_,64),"clutch3.sa", 
    DYNX(W_,61),"clutch3.tau0", 20)) OR PRE(DYNX(W_,73), 5) == -1 AND Greater(
    DYNX(X_,7),"clutch3.w_rel", DYNX(DP_,30),"clutch3.w_small", 21) OR initial()
     AND Greater(DYNX(X_,7),"clutch3.w_rel", 0,"0", 22));
  UpdateVariableNamed(DYNX(W_,66),"clutch3.startBackward", PRE(DYNX(W_,73), 5)
     == 0 AND (Less(DYNX(W_,64),"clutch3.sa",  -DYNX(W_,62)," -clutch3.tau0_max",
     23) OR PRE(DYNX(W_,66), 11) AND Less(DYNX(W_,64),"clutch3.sa",  -
    DYNX(W_,61)," -clutch3.tau0", 24)) OR PRE(DYNX(W_,73), 5) == 1 AND Less(
    DYNX(X_,7),"clutch3.w_rel",  -DYNX(DP_,30)," -clutch3.w_small", 25) OR 
    initial() AND Less(DYNX(X_,7),"clutch3.w_rel", 0,"0", 26));
  UpdateVariableNamed(DYNX(W_,67),"clutch3.locked",  NOT DYNX(W_,63) AND  NOT (
    PRE(DYNX(W_,73), 5) == 1 OR DYNX(W_,65) OR PRE(DYNX(W_,73), 5) == -1 OR 
    DYNX(W_,66)));
  MixedModeInit(24, DYNX(DYNhelp,87))
  ThetaMixedCross(0,3)
  ThetaMixedCross(1,4)
  ThetaMixedCross(2,5)
  ThetaMixedCross(3,6)
  ThetaMixedCross(4,7)
  ThetaMixedCross(5,8)
  ThetaMixedCross(6,9)
  ThetaMixedCross(7,10)
  ThetaMixedCross(8,11)
  ThetaMixedCross(9,12)
  ThetaMixedCross(10,13)
  ThetaMixedCross(11,14)
  ThetaMixedCross(12,15)
  ThetaMixedCross(13,16)
  ThetaMixedCross(14,17)
  ThetaMixedCross(15,18)
  ThetaMixedCross(16,19)
  ThetaMixedCross(17,20)
  ThetaMixedCross(18,21)
  ThetaMixedCross(19,22)
  ThetaMixedCross(20,23)
  ThetaMixedCross(21,24)
  ThetaMixedCross(22,25)
  ThetaMixedCross(23,26)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,9), 1)
  UpdateReal(DYNX(F_,1), 2)
  UpdateReal(DYNX(F_,3), 3)
  UpdateReal(DYNX(W_,1), 4)
  UpdateReal(DYNX(W_,32), 5)
  UpdateReal(DYNX(F_,5), 6)
  UpdateReal(DYNX(W_,38), 7)
  UpdateReal(DYNX(W_,28), 8)
  UpdateReal(DYNX(W_,58), 9)
  UpdateReal(DYNX(W_,64), 10)
  UpdateReal(DYNX(W_,54), 11)
  UpdateReal(DYNX(W_,85), 12)
  UpdateReal(DYNX(F_,7), 13)
EndMixedSystemOfEquations

DYNX(F_,0) = DYNX(X_,1);
DYNX(F_,6) = DYNX(X_,7);
DYNX(F_,4) = DYNX(X_,5);
DYNX(F_,2) = DYNX(X_,3);

AcceptedSection1
DYNX(W_,47) = IF DYNX(W_,37) THEN 2 ELSE IF (PRE(DYNX(W_,47), 3) == 1 OR PRE(
  DYNX(W_,47), 3) == 2 OR DYNX(W_,39)) AND Greater(DYNX(X_,5),"clutch2.w_rel", 0,
  "0", 14) THEN 1 ELSE IF (PRE(DYNX(W_,47), 3) == -1 OR PRE(DYNX(W_,47), 3) == 2
   OR DYNX(W_,40)) AND Less(DYNX(X_,5),"clutch2.w_rel", 0,"0", 18) THEN -1 ELSE 0;
DYNX(W_,18) = IF DYNX(W_,8) THEN 2 ELSE IF (PRE(DYNX(W_,18), 1) == 1 OR PRE(
  DYNX(W_,18), 1) == 2 OR DYNX(W_,10)) AND Greater(DYNX(X_,3),"clutch1.w_rel", 0,
  "0", 6) THEN 1 ELSE IF (PRE(DYNX(W_,18), 1) == -1 OR PRE(DYNX(W_,18), 1) == 2
   OR DYNX(W_,11)) AND Less(DYNX(X_,3),"clutch1.w_rel", 0,"0", 10) THEN -1 ELSE 0;
DYNX(W_,73) = IF DYNX(W_,63) THEN 2 ELSE IF (PRE(DYNX(W_,73), 5) == 1 OR PRE(
  DYNX(W_,73), 5) == 2 OR DYNX(W_,65)) AND Greater(DYNX(X_,7),"clutch3.w_rel", 0,
  "0", 22) THEN 1 ELSE IF (PRE(DYNX(W_,73), 5) == -1 OR PRE(DYNX(W_,73), 5) == 2
   OR DYNX(W_,66)) AND Less(DYNX(X_,7),"clutch3.w_rel", 0,"0", 26) THEN -1 ELSE 0;

AcceptedSection2
DYNX(W_,30) = DYNX(X_,2)+DYNX(X_,0);
DYNX(W_,56) = DYNX(X_,4)+DYNX(W_,30);
DYNX(W_,83) = DYNX(X_,6)+DYNX(W_,56);
DYNX(W_,31) = DYNX(X_,3)+DYNX(X_,1);
DYNX(W_,57) = DYNX(X_,5)+DYNX(W_,31);
DYNX(W_,84) = DYNX(X_,7)+DYNX(W_,57);
DYNX(W_,22) = DYNX(W_,1)*DYNX(X_,3);
DYNX(W_,51) = DYNX(W_,28)*DYNX(X_,5);
DYNX(W_,77) = DYNX(W_,54)*DYNX(X_,7);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("freqHz", "Frequency of sine function to invoke clutch1 [Hz]", 0,\
 0.2, 0.0,0.0,0.0,0,560)
DeclareParameter("T2", "Time when clutch2 is invoked [s]", 1, 0.4, 0.0,0.0,0.0,0,560)
DeclareParameter("T3", "Time when clutch3 is invoked [s]", 2, 0.9, 0.0,0.0,0.0,0,560)
DeclareAlias2("J1.flange_a.phi", "Absolute rotation angle of flange [rad|deg]", \
"J1.phi", 1, 1, 0, 4)
DeclareVariable("J1.flange_a.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("J1.flange_b.phi", "Absolute rotation angle of flange [rad|deg]", \
"J1.phi", 1, 1, 0, 4)
DeclareVariable("J1.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareParameter("J1.J", "Moment of inertia [kg.m2]", 3, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("J1.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("J1.phi", "Absolute rotation angle of component [rad|deg]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("J1.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("J1.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 1, 10, 0.0,0.0,0.0,0,560)
DeclareDerivative("J1.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("J1.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "J1.der(w)", 1, 6, 1, 0)
DeclareVariable("torque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("torque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J1.phi", 1, 1, 0, 4)
DeclareAlias2("torque.flange.tau", "Cut torque in the flange [N.m]", \
"J1.flange_a.tau", -1, 5, 0, 132)
DeclareAlias2("torque.support.phi", "Absolute rotation angle of the support/housing [rad|deg]",\
 "fixed.phi0", 1, 7, 38, 4)
DeclareAlias2("torque.support.tau", "Reaction torque in the support/housing [N.m]",\
 "J1.flange_a.tau", 1, 5, 0, 132)
DeclareAlias2("torque.phi_support", "Absolute angle of support flange [rad|deg]",\
 "fixed.phi0", 1, 7, 38, 1024)
DeclareAlias2("torque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "J1.flange_a.tau", 1, 5, 0, 0)
DeclareState("clutch1.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 2, 0, 0.0,0.0,0.0001,0,544)
DeclareDerivative("clutch1.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("clutch1.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 3, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("clutch1.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("clutch1.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "clutch1.der(w_rel)", 1, 6, 3, 0)
DeclareAlias2("clutch1.tau", "Torque between flanges (= flange_b.tau) [N.m]", \
"J1.flange_b.tau", 1, 5, 1, 0)
DeclareAlias2("clutch1.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J1.phi", 1, 1, 0, 4)
DeclareAlias2("clutch1.flange_a.tau", "Cut torque in the flange [N.m]", \
"J1.flange_b.tau", -1, 5, 1, 132)
DeclareAlias2("clutch1.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J2.phi", 1, 5, 30, 4)
DeclareAlias2("clutch1.flange_b.tau", "Cut torque in the flange [N.m]", \
"J1.flange_b.tau", 1, 5, 1, 132)
DeclareVariable("clutch1.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("clutch1.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareParameter("clutch1.mue_pos[1, 1]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 4, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("clutch1.mue_pos[1, 2]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 5, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("clutch1.peak", "peak*mue_pos[1,2] = maximum value of mue for w_rel==0 [1]",\
 6, 1.1, 1.0,1E+100,0.0,0,560)
DeclareParameter("clutch1.cgeo", "Geometry constant containing friction distribution assumption",\
 7, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("clutch1.fn_max", "Maximum normal force [N]", 8, 20, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("clutch1.w_small", "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]",\
 9, 10000000000.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("clutch1.w_relfric", "Relative angular velocity between frictional surfaces [rad/s]",\
 "clutch1.w_rel", 1, 1, 3, 0)
DeclareAlias2("clutch1.a_relfric", "Relative angular acceleration between frictional surfaces [rad/s2]",\
 "clutch1.der(w_rel)", 1, 6, 3, 0)
DeclareVariable("clutch1.tau0", "Friction torque for w_relfric=0 and forward sliding [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch1.tau0_max", "Maximum friction torque for w_relfric=0 and locked [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch1.free", "= true, if frictional element is not active [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("clutch1.sa", "Path parameter of friction characteristic tau = f(a_relfric) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch1.startForward", "= true, if w_relfric=0 and start of forward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("clutch1.startBackward", "= true, if w_relfric=0 and start of backward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("clutch1.locked", "true, if w_rel=0 and not sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("clutch1.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch1.Free", "Element is not active [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("clutch1.Forward", "w_relfric > 0 (forward sliding) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch1.Stuck", "w_relfric = 0 (forward sliding, locked or backward sliding) [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch1.Backward", "w_relfric < 0 (backward sliding) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch1.mode", "Mode of friction (-1: backward sliding, 0: stuck, 1: forward sliding, 2: inactive, 3: unknown) [:#(type=Integer)]",\
 3, -1.0,3.0,0.0,0,660)
DeclareVariable("clutch1.unitAngularAcceleration", "[rad/s2]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("clutch1.unitTorque", "[N.m]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("clutch1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("clutch1.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch1.mue0", "Friction coefficient for w=0 and forward sliding",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("clutch1.fn", "Normal force (fn=fn_max*f_normalized) [N]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("clutch1.f_normalized", "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("sin1.amplitude", "Amplitude of sine wave", 10, 10, 0.0,0.0,0.0,\
0,560)
DeclareParameter("sin1.freqHz", "Frequency of sine wave [Hz]", 11, 5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sin1.phase", "Phase of sine wave [rad|deg]", 12, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sin1.offset", "Offset of output signal [N.m]", 13, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sin1.startTime", "Output = offset for time < startTime [s]", 14,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("sin1.y", "Connector of Real output signal [N.m]", \
"J1.flange_a.tau", 1, 5, 0, 0)
DeclareParameter("step1.height", "Height of step [1]", 15, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("step1.y", "Connector of Real output signal [1]", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareParameter("step1.offset", "Offset of output signal y [1]", 16, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("step1.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("J2.flange_a.phi", "Absolute rotation angle of flange [rad|deg]", \
"J2.phi", 1, 5, 30, 4)
DeclareAlias2("J2.flange_a.tau", "Cut torque in the flange [N.m]", \
"J1.flange_b.tau", -1, 5, 1, 132)
DeclareAlias2("J2.flange_b.phi", "Absolute rotation angle of flange [rad|deg]", \
"J2.phi", 1, 5, 30, 4)
DeclareVariable("J2.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareParameter("J2.J", "Moment of inertia [kg.m2]", 17, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("J2.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("J2.phi", "Absolute rotation angle of component [rad|deg]", 0, \
0.0,0.0,0.0,0,528)
DeclareAlias2("J2.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "J2.w", 1, 5, 31, 0)
DeclareVariable("J2.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0, 0.0,0.0,0.0,0,528)
DeclareVariable("J2.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("J2.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "J2.der(w)", 1, 5, 32, 0)
DeclareState("clutch2.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 4, 0, 0.0,0.0,0.0001,0,544)
DeclareDerivative("clutch2.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("clutch2.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 5, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("clutch2.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("clutch2.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "clutch2.der(w_rel)", 1, 6, 5, 0)
DeclareAlias2("clutch2.tau", "Torque between flanges (= flange_b.tau) [N.m]", \
"J2.flange_b.tau", 1, 5, 28, 0)
DeclareAlias2("clutch2.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J2.phi", 1, 5, 30, 4)
DeclareAlias2("clutch2.flange_a.tau", "Cut torque in the flange [N.m]", \
"J2.flange_b.tau", -1, 5, 28, 132)
DeclareAlias2("clutch2.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J3.phi", 1, 5, 56, 4)
DeclareAlias2("clutch2.flange_b.tau", "Cut torque in the flange [N.m]", \
"J2.flange_b.tau", 1, 5, 28, 132)
DeclareVariable("clutch2.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("clutch2.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareParameter("clutch2.mue_pos[1, 1]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 18, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("clutch2.mue_pos[1, 2]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 19, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("clutch2.peak", "peak*mue_pos[1,2] = maximum value of mue for w_rel==0 [1]",\
 20, 1.1, 1.0,1E+100,0.0,0,560)
DeclareParameter("clutch2.cgeo", "Geometry constant containing friction distribution assumption",\
 21, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("clutch2.fn_max", "Maximum normal force [N]", 22, 20, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("clutch2.w_small", "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]",\
 23, 10000000000.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("clutch2.w_relfric", "Relative angular velocity between frictional surfaces [rad/s]",\
 "clutch2.w_rel", 1, 1, 5, 0)
DeclareAlias2("clutch2.a_relfric", "Relative angular acceleration between frictional surfaces [rad/s2]",\
 "clutch2.der(w_rel)", 1, 6, 5, 0)
DeclareVariable("clutch2.tau0", "Friction torque for w_relfric=0 and forward sliding [N.m]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("clutch2.tau0_max", "Maximum friction torque for w_relfric=0 and locked [N.m]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("clutch2.free", "= true, if frictional element is not active [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("clutch2.sa", "Path parameter of friction characteristic tau = f(a_relfric) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch2.startForward", "= true, if w_relfric=0 and start of forward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("clutch2.startBackward", "= true, if w_relfric=0 and start of backward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("clutch2.locked", "true, if w_rel=0 and not sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("clutch2.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch2.Free", "Element is not active [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("clutch2.Forward", "w_relfric > 0 (forward sliding) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch2.Stuck", "w_relfric = 0 (forward sliding, locked or backward sliding) [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch2.Backward", "w_relfric < 0 (backward sliding) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch2.mode", "Mode of friction (-1: backward sliding, 0: stuck, 1: forward sliding, 2: inactive, 3: unknown) [:#(type=Integer)]",\
 3, -1.0,3.0,0.0,0,660)
DeclareVariable("clutch2.unitAngularAcceleration", "[rad/s2]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("clutch2.unitTorque", "[N.m]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("clutch2.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("clutch2.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch2.mue0", "Friction coefficient for w=0 and forward sliding",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("clutch2.fn", "Normal force (fn=fn_max*f_normalized) [N]", 0.0, \
0.0,0.0,0.0,0,640)
DeclareAlias2("clutch2.f_normalized", "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0) [1]",\
 "step1.y", 1, 5, 26, 0)
DeclareAlias2("J3.flange_a.phi", "Absolute rotation angle of flange [rad|deg]", \
"J3.phi", 1, 5, 56, 4)
DeclareAlias2("J3.flange_a.tau", "Cut torque in the flange [N.m]", \
"J2.flange_b.tau", -1, 5, 28, 132)
DeclareAlias2("J3.flange_b.phi", "Absolute rotation angle of flange [rad|deg]", \
"J3.phi", 1, 5, 56, 4)
DeclareVariable("J3.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareParameter("J3.J", "Moment of inertia [kg.m2]", 24, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("J3.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("J3.phi", "Absolute rotation angle of component [rad|deg]", 0, \
0.0,0.0,0.0,0,528)
DeclareAlias2("J3.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "J3.w", 1, 5, 57, 0)
DeclareVariable("J3.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0, 0.0,0.0,0.0,0,528)
DeclareVariable("J3.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("J3.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "J3.der(w)", 1, 5, 58, 0)
DeclareState("clutch3.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 6, 0, 0.0,0.0,0.0001,0,544)
DeclareDerivative("clutch3.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("clutch3.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 7, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("clutch3.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("clutch3.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "clutch3.der(w_rel)", 1, 6, 7, 0)
DeclareAlias2("clutch3.tau", "Torque between flanges (= flange_b.tau) [N.m]", \
"J3.flange_b.tau", 1, 5, 54, 0)
DeclareAlias2("clutch3.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J3.phi", 1, 5, 56, 4)
DeclareAlias2("clutch3.flange_a.tau", "Cut torque in the flange [N.m]", \
"J3.flange_b.tau", -1, 5, 54, 132)
DeclareAlias2("clutch3.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "J4.phi", 1, 5, 83, 4)
DeclareAlias2("clutch3.flange_b.tau", "Cut torque in the flange [N.m]", \
"J3.flange_b.tau", 1, 5, 54, 132)
DeclareVariable("clutch3.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("clutch3.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareParameter("clutch3.mue_pos[1, 1]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 25, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("clutch3.mue_pos[1, 2]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 26, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("clutch3.peak", "peak*mue_pos[1,2] = maximum value of mue for w_rel==0 [1]",\
 27, 1.1, 1.0,1E+100,0.0,0,560)
DeclareParameter("clutch3.cgeo", "Geometry constant containing friction distribution assumption",\
 28, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("clutch3.fn_max", "Maximum normal force [N]", 29, 20, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("clutch3.w_small", "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]",\
 30, 10000000000.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("clutch3.w_relfric", "Relative angular velocity between frictional surfaces [rad/s]",\
 "clutch3.w_rel", 1, 1, 7, 0)
DeclareAlias2("clutch3.a_relfric", "Relative angular acceleration between frictional surfaces [rad/s2]",\
 "clutch3.der(w_rel)", 1, 6, 7, 0)
DeclareVariable("clutch3.tau0", "Friction torque for w_relfric=0 and forward sliding [N.m]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("clutch3.tau0_max", "Maximum friction torque for w_relfric=0 and locked [N.m]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("clutch3.free", "= true, if frictional element is not active [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("clutch3.sa", "Path parameter of friction characteristic tau = f(a_relfric) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch3.startForward", "= true, if w_relfric=0 and start of forward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("clutch3.startBackward", "= true, if w_relfric=0 and start of backward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("clutch3.locked", "true, if w_rel=0 and not sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("clutch3.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch3.Free", "Element is not active [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("clutch3.Forward", "w_relfric > 0 (forward sliding) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch3.Stuck", "w_relfric = 0 (forward sliding, locked or backward sliding) [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch3.Backward", "w_relfric < 0 (backward sliding) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareVariable("clutch3.mode", "Mode of friction (-1: backward sliding, 0: stuck, 1: forward sliding, 2: inactive, 3: unknown) [:#(type=Integer)]",\
 3, -1.0,3.0,0.0,0,660)
DeclareVariable("clutch3.unitAngularAcceleration", "[rad/s2]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("clutch3.unitTorque", "[N.m]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("clutch3.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("clutch3.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("clutch3.mue0", "Friction coefficient for w=0 and forward sliding",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("clutch3.fn", "Normal force (fn=fn_max*f_normalized) [N]", 0.0, \
0.0,0.0,0.0,0,640)
DeclareVariable("clutch3.f_normalized", "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0) [1]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("J4.flange_a.phi", "Absolute rotation angle of flange [rad|deg]", \
"J4.phi", 1, 5, 83, 4)
DeclareAlias2("J4.flange_a.tau", "Cut torque in the flange [N.m]", \
"J3.flange_b.tau", -1, 5, 54, 132)
DeclareAlias2("J4.flange_b.phi", "Absolute rotation angle of flange [rad|deg]", \
"J4.phi", 1, 5, 83, 4)
DeclareVariable("J4.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareParameter("J4.J", "Moment of inertia [kg.m2]", 31, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("J4.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("J4.phi", "Absolute rotation angle of component [rad|deg]", 0, \
0.0,0.0,0.0,0,528)
DeclareAlias2("J4.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "J4.w", 1, 5, 84, 0)
DeclareVariable("J4.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0, 0.0,0.0,0.0,0,528)
DeclareVariable("J4.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("J4.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "J4.der(w)", 1, 5, 85, 0)
DeclareParameter("sin2.amplitude", "Amplitude of sine wave", 32, 1, 0.0,0.0,0.0,\
0,560)
DeclareVariable("sin2.freqHz", "Frequency of sine wave [Hz]", 1, 0.0,0.0,0.0,0,513)
DeclareParameter("sin2.phase", "Phase of sine wave [rad|deg]", 33, 1.57, \
0.0,0.0,0.0,0,560)
DeclareParameter("sin2.offset", "Offset of output signal [1]", 34, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sin2.startTime", "Output = offset for time < startTime [s]", 35,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("sin2.y", "Connector of Real output signal [1]", "clutch1.f_normalized", 1,\
 5, 25, 0)
DeclareParameter("step2.height", "Height of step [1]", 36, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("step2.y", "Connector of Real output signal [1]", "clutch3.f_normalized", 1,\
 5, 80, 0)
DeclareParameter("step2.offset", "Offset of output signal y [1]", 37, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("step2.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("fixed.phi0", "Fixed offset angle of housing [rad|deg]", 38, 0,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "fixed.phi0", 1, 7, 38, 4)
DeclareAlias2("fixed.flange.tau", "Cut torque in the flange [N.m]", \
"J1.flange_a.tau", -1, 5, 0, 132)
DeclareOutput("CPUtime", "[s]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 1, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preWD(DYNX(W_,8),"clutch1.free", false, 0);
preD(DYNX(W_,18),"clutch1.mode", 3, 1);
pre(DYNX(W_,11),"clutch1.startBackward", false, 7);
pre(DYNX(W_,10),"clutch1.startForward", false, 6);
preWD(DYNX(W_,37),"clutch2.free", false, 2);
preD(DYNX(W_,47),"clutch2.mode", 3, 3);
pre(DYNX(W_,40),"clutch2.startBackward", false, 9);
pre(DYNX(W_,39),"clutch2.startForward", false, 8);
preWD(DYNX(W_,63),"clutch3.free", false, 4);
preD(DYNX(W_,73),"clutch3.mode", 3, 5);
pre(DYNX(W_,66),"clutch3.startBackward", false, 11);
pre(DYNX(W_,65),"clutch3.startForward", false, 10);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,9), 0.0, 3);
DoRemember_(DYNX(W_,38), 0.0, 2);
DoRemember_(DYNX(W_,64), 0.0, 1);
DoRemember_(DYNX(F_,1), 0.0, 0);
EndEqBlock
EndDataBlock
